# 创建型模式

### 单例模式
* 背景：确保一个类只有一个实例
* [饿汉式](https://github.com/y0711/design-patterns/blob/master/Singleton2.java)
类加载时就创建实例
* [懒汉式](https://github.com/y0711/design-patterns/blob/master/Singleton.java)
  * 在类加载时不创建实例，等到第一次被调用时才创建实例（延迟加载技术）。
  * 为确保线程安全，需要对整个函数锁定，或者对部分函数双重检查锁定。
* 对比
  * 饿汉：不需要考虑多线程问题。但不需要时也会创建实例。
  * 懒汉：需考虑多线程问题。加载时慢，且锁定会影响系统性能。
* 折衷：建一个静态内部类，[在该内部类中创建单例对象](https://github.com/y0711/design-patterns/blob/master/Singleton3.java)。这样，类加载时不会实例化单例，只在第一次调用的时候才实例化。由Java虚拟机保证线程安全，无需锁定。

### 简单工厂模式
* 背景：要把类的创建和使用分开(职责明晰)。有时候，创建一个类需要复杂的初始化，使用工厂类就更有必要了。
* [做法](https://github.com/y0711/design-patterns/blob/master/SimpleFactory.java)：由工厂类来负责类的创建。抽象产品，工厂类则根据参数选择生产哪一个具体产品。

### 工厂模式
* 简单工厂模式缺点：加入新产品时，要改动很多代码。
* [解决方法](https://github.com/y0711/design-patterns/blob/master/Factory.java)：抽象产品，抽象工厂。一个具体的工厂生产一个具体的产品。另外，可过配置文件+反射来决定生产哪个产品，无需重新编译代码。

### 抽象工厂模式
* 工厂模式缺点：一个工厂只生产一个产品，需要大量的工厂类。
* 解决方法：一个工厂生产一组相关的产品，即产品族。[本例](https://github.com/y0711/design-patterns/blob/master/AbstractFactory.java)一个工厂生产两种新产品：Button 和 Text

### 原型模式
* 背景：已经有一个实例了，还想再要一个相似的实例
* 做法
  * [土方法](https://github.com/y0711/design-patterns/blob/master/ProtoType.java)：新建一个实例，并用旧实例来赋值
  * [Java提供的](https://github.com/y0711/design-patterns/blob/master/ProtoType2.java)：实现Cloneable接口，覆盖它的clone方法
  * 上述clone是[浅clone](https://github.com/y0711/design-patterns/blob/master/ProtoType3.java)，它只复制值和引用，不复制引用的对象
  * 通过序列化技术，将对象写到一个流中，再读出来，可以实现[深clone](https://github.com/y0711/design-patterns/blob/master/ProtoType4.java)。做法：要实现序列化的对象都要实现Serializable接口。

### 建造者模式
* 背景：想要一步一步组装一个复杂的对象
* 做法：实现抽象建造者(builder)，具体建造者，指挥者(director)，和产品(product)对象这[四个角色](https://github.com/y0711/design-patterns/blob/master/Builder.java)。
* 变形1：可以[省略指挥者](https://github.com/y0711/design-patterns/blob/master/Builder2.java)，让builder来完成组装的职责。
* 变形2：可以在采用builder中加入钩子方法(hook)来[调节director的组装过程](https://github.com/y0711/design-patterns/blob/master/Builder3.java)。

# 结构型模式

### 适配器模式
* 背景：想把一个接口转成另一个接口。又叫包装器(wrapper)。
* 实现：一个目标接口类(Target)，一个要适配的类(Adaptee)，一个适配器类(Adapter)。
  * 对象适配（常用），即Adapter继承自Target，并拥有一个Adaptee类
  * 类适配，即让Adapter类继承Adaptee，并实现Target。由于Java不能多继承，故若Target不是接口（是抽象类），就不行了。
* 变种：双向适配器（不常用）。Adapter同时拥有Adaptee和Target，使得Adaptee和Target能相互调用对方的方法。
* 缺省适配器模式：设计一个抽象类（称为缺少适配器），提供某接口的默认实现（空方法）。这样，该抽象类的子类只用在必要时候覆盖抽象类的方法即可。而如果直接子类直接实现该接口，那些用不到的接口方法也得提供空的实现，麻烦。

### 桥接模式
* 背景：某个类有两个维度，独立变化。如果采用继承，类的数目会非常多。
* [实现](https://github.com/y0711/design-patterns/blob/master/Bridge.java)：把某个与业务关系最紧密的维度设计为抽象类的层次（抽象），另一个维度设计为类层次结构（实现）。比如毛笔，把尺寸作为抽象，把墨汁颜色作为实现。毛笔->大号/小号毛笔，墨汁->红墨汁/黑墨汁，毛笔拥有墨汁。

### 组合模式
* 背景：构建和处理树形的结构。把容器对象和叶子对象进行递归组合。
* 做法：抽象构件，派生出叶子构件和容器构件。
  * [变种1](https://github.com/y0711/design-patterns/blob/master/Composite.java)：透明组合模式。在抽象构件中声明所有的操作方法，在叶子构件和容器构件中实现它们。注意，叶子构件中的管理子构件的方法是不合法的，故这些方法要通过捕获异常的形式来实现。当然也可以在抽象构件中给出默认实现（当然还是以捕获异常的形式）。变种1的缺点是客户端调用不当时会出现异常。
  * 变种2：安全组合模式。在抽象构件中只声明公共的方法，由叶子构件和容器构件实现。而管理子构件的方法则只在容器构件中声明和定义。缺点是客户端不再针对抽象编程。

### 装饰模式
* 背景：为对象添加额外的新功能。
* 做法：抽象构件->具体构件。抽象装饰类继承自抽象构件，并拥有一个抽象构件。具体装饰类继承自抽象装饰类。
  * [变种1](https://github.com/y0711/design-patterns/blob/master/Decorator.java)：透明装饰模式。具体类新增的行为在覆盖后的函数中调用。对客户端而言，具体构建对象和个体装饰对象没区别，可以一致对待。
  * 变种2：半透明装饰模式。具体装饰类新增加的行为需要单独调用。因此装饰后的对象要用具体装饰类型来定义，否则无法调用新增的函数。灵活，使用方便，但无法实现对同一对象的多次装饰。
  
### 外观模式
* 背景：为一组子系统提供一个统一的入口。客户端不用分别跟多个子系统打交道，只需要跟外观类打交道即可。
* [实现](https://github.com/y0711/design-patterns/blob/master/Facade.java)新增一个外观类即可。也可以设计一个接口，充当抽象的外观类，客户端针对此接口编程。

### 享元模式
* 背景：系统中存在大量相同或相似的对象
* [解决方法](https://github.com/y0711/design-patterns/commit/4944d06e74108c1d7a129be28718cb8a74a3a4fc)：抽象享元类，具体享元类，享元工厂（享元池）
* [变种](https://github.com/y0711/design-patterns/commit/e246c32365bb23cb146909ba7b966ad12ad886f6)带外部状态的解决方案
