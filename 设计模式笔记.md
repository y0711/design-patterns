# 创建型模式

### 单例模式
* 背景：确保一个类只有一个实例
* 饿汉式：[Singleton2](https://github.com/y0711/design-patterns/blob/master/Singleton2.java)
类加载时就创建实例.
* 懒汉式：[Singleton](https://github.com/y0711/design-patterns/blob/master/Singleton.java)
  * 在类加载时不创建实例，等到第一次被调用时才创建实例（延迟加载技术）。
  * 为确保线程安全，需要对整个函数锁定，或者对部分函数双重检查锁定。
* 对比
  * 饿汉：不需要考虑多线程问题。但不需要时也会创建实例。
  * 懒汉：需考虑多线程问题。加载时慢，且锁定会影响系统性能。
* 折衷：建一个静态内部类，在该内部类中创建单例对象。
* [Singleton3](https://github.com/y0711/design-patterns/blob/master/Singleton3.java)
这样，类加载时不会实例化单例，只在第一次调用的时候才实例化。由Java虚拟机保证线程安全，无需锁定。

### 简单工厂模式
* 背景：要把类的创建和使用分开(职责明晰)。有时候，创建一个类需要复杂的初始化，使用工厂类就更有必要了。
* 做法：由工厂类来负责类的创建。抽象产品，工厂类则根据参数选择生产哪一个具体产品。
* [SimpleFactory](https://github.com/y0711/design-patterns/blob/master/SimpleFactory.java)

### 工厂模式
* 简单工厂模式缺点：加入新产品时，要改动很多代码。
* 解决方法：抽象产品，抽象工厂。一个具体的工厂生产一个具体的产品。
* [Factory](https://github.com/y0711/design-patterns/blob/master/Factory.java)
可过配置文件+反射来决定生产哪个产品，无需重新编译代码。

### 抽象工厂模式
* 工厂模式缺点：一个工厂只生产一个产品，需要大量的工厂类。
* 解决方法：一个工厂生产一组相关的产品，即产品族。
* [AbstractFactory](https://github.com/y0711/design-patterns/blob/master/AbstractFactory.java)
一个工厂生产两种新产品：Button 和 Text

### 原型模式
* 背景：已经有一个实例了，还想再要一个相似的实例
* 做法
  * [土方法](https://github.com/y0711/design-patterns/blob/master/ProtoType.java)：新建一个实例，并用旧实例来赋值
  * [Java提供的](https://github.com/y0711/design-patterns/blob/master/ProtoType2.java)：实现Cloneable接口，覆盖它的clone方法
  * 上述clone是[浅clone](https://github.com/y0711/design-patterns/blob/master/ProtoType3.java)，它只复制值和引用，不复制引用的对象
  * 通过序列化技术，将对象写到一个流中，再读出来，可以实现[深clone](https://github.com/y0711/design-patterns/blob/master/ProtoType4.java)。做法：要实现序列化的对象都要实现Serializable接口。
