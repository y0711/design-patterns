# 创建型模式

### 单例模式
* 背景：确保一个类只有一个实例
* [饿汉式](https://github.com/y0711/design-patterns/blob/master/Singleton2.java)
类加载时就创建实例
* [懒汉式](https://github.com/y0711/design-patterns/blob/master/Singleton.java)
  * 在类加载时不创建实例，等到第一次被调用时才创建实例（延迟加载技术）。
  * 为确保线程安全，需要对整个函数锁定，或者对部分函数双重检查锁定。
* 对比
  * 饿汉：不需要考虑多线程问题。但不需要时也会创建实例。
  * 懒汉：需考虑多线程问题。加载时慢，且锁定会影响系统性能。
* 折衷：建一个静态内部类，[在该内部类中创建单例对象](https://github.com/y0711/design-patterns/blob/master/Singleton3.java)。这样，类加载时不会实例化单例，只在第一次调用的时候才实例化。由Java虚拟机保证线程安全，无需锁定。

### 简单工厂模式
* 背景：要把类的创建和使用分开(职责明晰)。有时候，创建一个类需要复杂的初始化，使用工厂类就更有必要了。
* [做法](https://github.com/y0711/design-patterns/blob/master/SimpleFactory.java)：由工厂类来负责类的创建。抽象产品，工厂类则根据参数选择生产哪一个具体产品。

### 工厂模式
* 简单工厂模式缺点：加入新产品时，要改动很多代码。
* [解决方法](https://github.com/y0711/design-patterns/blob/master/Factory.java)：抽象产品，抽象工厂。一个具体的工厂生产一个具体的产品。另外，可过配置文件+反射来决定生产哪个产品，无需重新编译代码。

### 抽象工厂模式
* 工厂模式缺点：一个工厂只生产一个产品，需要大量的工厂类。
* 解决方法：一个工厂生产一组相关的产品，即产品族。[本例](https://github.com/y0711/design-patterns/blob/master/AbstractFactory.java)一个工厂生产两种新产品：Button 和 Text

### 原型模式
* 背景：已经有一个实例了，还想再要一个相似的实例
* 做法
  * [土方法](https://github.com/y0711/design-patterns/blob/master/ProtoType.java)：新建一个实例，并用旧实例来赋值
  * [Java提供的](https://github.com/y0711/design-patterns/blob/master/ProtoType2.java)：实现Cloneable接口，覆盖它的clone方法
  * 上述clone是[浅clone](https://github.com/y0711/design-patterns/blob/master/ProtoType3.java)，它只复制值和引用，不复制引用的对象
  * 通过序列化技术，将对象写到一个流中，再读出来，可以实现[深clone](https://github.com/y0711/design-patterns/blob/master/ProtoType4.java)。做法：要实现序列化的对象都要实现Serializable接口。

### 建造者模式
* 背景：想要一步一步组装一个复杂的对象
* 做法：实现抽象建造者(builder)，具体建造者，指挥者(director)，和产品(product)对象这[四个角色](https://github.com/y0711/design-patterns/blob/master/Builder.java)。
* 变形1：可以[省略指挥者](https://github.com/y0711/design-patterns/blob/master/Builder2.java)，让builder来完成组装的职责。
* 变形2：可以在采用builder中加入钩子方法(hook)来[调节director的组装过程](https://github.com/y0711/design-patterns/blob/master/Builder3.java)。

# 结构型模式

### 适配器模式
* 背景：想把一个接口转成另一个接口。又叫包装器(wrapper)。
* 实现：一个目标接口类(Target)，一个要适配的类(Adaptee)，一个适配器类(Adapter)。
  * 对象适配（常用），即Adapter继承自Target，并拥有一个Adaptee类
  * 类适配，即让Adapter类继承Adaptee，并实现Target。由于Java不能多继承，故若Target不是接口（是抽象类），就不行了。
* 变种：双向适配器（不常用）。Adapter同时拥有Adaptee和Target，使得Adaptee和Target能相互调用对方的方法。
* 缺省适配器模式：设计一个抽象类（称为缺少适配器），提供某接口的默认实现（空方法）。这样，该抽象类的子类只用在必要时候覆盖抽象类的方法即可。而如果直接子类直接实现该接口，那些用不到的接口方法也得提供空的实现，麻烦。

### 桥接模式
* 背景：某个类有两个维度，独立变化。如果采用继承，类的数目会非常多。
* 实现：把某个与业务关系最紧密的维度设计为抽象类的层次（抽象），另一个维度设计为类层次结构（实现）。比如毛笔，把尺寸作为
